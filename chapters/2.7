众所周知，理论上，URL能够定位到互联网上的任何资源。同理，对于一个web应用而言， 也可以使用URL来表示该应用的任意状态。比如当前登录用户，所处页面，所做操作，甚至可以细到页面上每一个DOM节点的任何属性，都可以在URL上反映出来。不过所想表示的状态越多越细，相应的URL就会越长。虽然RFC2616并没有对URL的长度作出限制，但是在现实中，一般认为2000个字符以下的URL，才能够被大部分浏览器和服务器正确识别。因此，在现实中，使用URL并不能够表示web应用的每一个细节（通常也没有必要）。目前主流前端框架的共识是，将整个页面当作是web应用的一种状态（而不过分考虑页面细节），不同的页面用不同的URL来表示，通过改变URL来定位到相应的页面。这种机制，称之为路由。（SPA？）

Angular2也实现了类似的路由机制。在Angular2中，一个页面由一个或多个Component组合而成，不同的Component组合生成了不同的页面。因此可以给每一种Component组合指定相应的URL（数目不限），当浏览器上URL发生改变时，Angular2会捕捉到相应的事件，从而渲染出相应的页面。

下面先通过一个简单的例子来介绍路由的基本功能。这个例子包含了一个主页面和两个Component，将使用路由来控制两个Component在主页面上的展现。
app.component.ts
import { bootstrap } from 'angular2/platform/browser';
import { Component } from 'angular2/core';
import { ComponentA } from './a.component';
import { ComponentB } from './b.component';

@Component({
  selector: 'my-app',
  template: '<h1>Master Page</h1>'
})
class AppComponent {}

bootstrap(AppComponent);
a.component.ts
import { Component } from 'angular2/core';

@Component({
  template: '<div>Component A</div>'
})
export class ComponentA {}
b.components.ts
import { Component } from 'angular2/core';

@Component({
  template: '<div>Component B</div>'
})
export class ComponentB {}



加载路由库
由于并不是所有的web app都需要使用路由的功能，Angular2把路由设计成了一个独立的模块，没有包含在其核心模块angular2/core之中。因此，在使用路由功能之前，需要先将其加载进来。下面的语句加载了路由模块的3个类：RouteConfig用于定义和配置路由，ROUTER_DIRECTIVES包含了路由相关的指令，ROUTER_PROVIDERS则用于初始化路由实例。
app.component.ts
import { RouteConfig, ROUTER_DIRECTIVES, ROUTER_PROVIDERS } from 'angular2/router';

bootstrap(AppComponent, [ROUTER_PROVIDERS]);


设置base路径
？？只是PathLocationStrategy才需要base？？
Angular2规定，要使用路由模块，需要首先为整个app定义一个base路径，否则路由模块将无法成功加载。设置base路径的方式有两种：
1. 使用html的<base>元素。这个元素的作用是给整个页面设置了一个base路径，页面上所有的相对路径都将基于此base路径来解析。Angular2在初始化路由策略的时候，会尝试在页面上寻找该元素，并将其href属性的值作为app的base路径。
根据HTML5标准的规定，<base>元素只能做为<head>元素的子元素。下面在index.html中添加一个值为／的base路径。
<head>
  <title></title>
  <base href="/">
  <!--其他-->
<head>
2. APP_BASE_HREF token
第一种方式是Angular2官方推荐的，但是如果现实中项目不适宜使用<base>元素，或者开发者无权限改动index.html的时候，Angular2还提供了一种方式，使用APP_BASE_HREF token。如果既设置了<base>元素，也使用了APP_BASE_HREF token，则后者的值会被用作base路径。
app.component.ts
import { Component, provide } from 'angular2/core';
import { RouteConfig, ROUTER_DIRECTIVES, ROUTER_PROVIDERS, APP_BASE_HREF } from 'angular2/router';

bootstrap(AppComponent, [
  ROUTER_PROVIDERS,
  provide(APP_BASE_HREF, {useValue : '/' })
]);


定义路由 RouteDefinition
在加载完RouteConfig之后，便可以使用其定义路由。前面提到过，路由最主要的作用是将URL和Component关联起来，所以在定义路由的时候，这两者是必须的要素，分别由path和component属性来定义。同时，Angular2规定，不同路由的URL必须不同，但是不同的URL可以指向同一个Component。
下面的代码分别给ComponentA和ComponentB定义了一条路由：
app.component.ts
@RouteConfig([
  {
    path: '/component-a',
    component: ComponentA
  },
  {
    path: '/component-b',
    component: ComponentB
  }
])

路由指令
在模版中，所有和路由的交互，都是通过路由指令来完成。Angular2提供了一系列路由指令，均封装在了ROUTER_DIRECTIVES这个类中。

<router-outlet>
这个指令的作用相当于一个占位节点，在模版中开辟出一块区域，每个路由所对应的Component都将在这个区域内显示出来。
下面的代码在主页面上添加了<router-outlet>。此时在浏览器上输入两个不同路由的URL（http://localhost/component-a和http://localhost/component-b），便可以看到其所对应的Component被渲染出来。
app.component.ts
@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})


A template may hold exactly one unnamed <router-outlet>. How to specify named outlet?
能不能根据不同的路由，控制routerOutlet?


[routerLink]
大多数情况下，页面的跳转是通过超链接元素<a>来完成的，所以上例的模版可以进一步扩展如下。其中第二个超链接使用了Angular2的变量替换，这意味着URL的指向可以被动态修改，使得app可以根据用户的不同操作而提供指向不同Component的URL。
@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <nav>
      <a href="/component-a">Component A</a>
      <a href="{{path_b}}">Component B</a>
    </nav>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})

class AppComponent {
  path_b = '/component-b';
}

上面的例子，有一个值得注意的地方，就是点击超链接之后，浏览器都会给后台服务器发一个请求，从而整个app会被重新加载一遍。虽然说加载完成后，路由所对应的Component也会被正确地显示出来，但这种加载是完全可以避免的，因为路由所需要的Component早已经在主页面app.component.ts中被加载了进来：
import { ComponentA } from './a.component';
import { ComponentB } from './b.component';
要避免这种重新加载，可以使用[routerLink]指令。该指令会监听其所处DOM元素的click事件，并在事件被触发时，跳转到指定的URL。对于<a>元素，是通过path值来对其指定路由；对于[routerLink]指令，则需要用路由的名字来进行指定。
在下面的例子中，首先路由定义中使用name属性给各个路由进行命名，然后再在模版中将各名字分别赋予[routerLink]指令。
@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <nav>
      <a [routerLink]="['Component-A']">Component A</a>
      <button [routerLink]="[name_b]">Component B</button>
    </nav>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
@RouteConfig([
  {
    path: '/component-a',
    name: 'Component-A',
    component: ComponentA
  },
  {
    path: '/component-b',
    name: 'Component-B',
    component: ComponentB
  }
])
class AppComponent {
  name_b = 'Component-B';
}

bootstrap(AppComponent, [ROUTER_PROVIDERS]);

在组件中传递  
除了直接修改浏览器URL和使用routerLink指令，Angular2还提供了API接口，允许在运行时触发路由跳转。
下面的例子首先加载了Router类，并且在点击时间的回调函数中执行Router.navigate()方法触发跳转。该方法和routerLink指令一样，其参数为一个链接参数数组。
app.component.ts
//其他需要import的文件省略
import { Router } from 'angular2/router';

@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <nav>
      <a [routerLink]="['Component-A', {id:1}]">Component A</a>
      <button (click)="onClick()">Component A</button>
    </nav>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
//@RouteConfig部分省略
class AppComponent {
  constructor(private router: Router){  }

  onClick(){
    this.router.navigate(['Component-A', {id:1}]);
  }
}


生命周期
和组件一样，路由也具有生命周期。并且在生命周期的不同阶段提供了相应的钩子，如CanActivate和CanDeactivate，通过这些钩子，能够对路由的行为进行控制。

CanDeactivate
前面的例子展示了，使用[routerLink]指令或者调用Router.navigate()方法，可以触发路由跳转。在跳转发生前，当前路由会先进入CanDeactivate生命周期。Angular2为该生命周期定义了一个同名接口，该接口包含一个routerCanDeactivate()方法，该方法必须返回一个Promise。当Promise被resolve为true时，则进入下一个路由；被resolve为false时，则继续停留在当前路由。

默认情况下，当前路由所对应的Component不会实现CanDeactivate接口，所以会直接由当前路由跳转到下一个路由；如果实现了该接口，那么Angular2将会调用routerCanDeactivate()方法，并将根据其返回值来决定路由的下一步走向。

下面的例子中，ComponentA实现了接口CanDeactivate。假设当前路由为Component-A，用户点击了<button>想跳转到Component-B，此时页面会通过window.confirm弹出一个确认框：如果用户选了［是］，则Promise被resolve为true，则会跳转到Component-B；如果选了［否］，则跳转取消，继续停留在当前路由。
a.component.ts
import { Component } from 'angular2/core';
import { CanDeactivate, ComponentInstruction } from 'angular2/router';

@Component({
  template: `
    <div>Component A</div>
  `
})
export class ComponentA implements CanDeactivate {
  routerCanDeactivate(next: ComponentInstruction, prev: ComponentInstruction) {
    return new Promise<boolean>((resolve, reject) => {
      resolve(window.confirm('确认跳转？'));
    });
  }
}

路由参数
到目前为止，已经实现了一个简单的路由，即可以通过静态的URL将其对应的Component显示出来。但是对于动态页面，除了知道要显示哪个Component之外，还需要指定该Component所要显示的具体内容。在Angular2中，可以通过设置路由参数，来向Component传递信息。

定义路由参数
要定义路由参数，首先需要了解Angular2是如何解析路由的path值：
1. 如果path的字符串以／号开头，则去掉该／号
2. 再以／号为分隔符，对剩余的字符串分段
3. 每一段，如果以：开头，则表示路由参数
下面的例子，path字符串会被分割成四段，分别为"component-a", ":id", "segment-x", ":name"，其中":id"，":name"表示路由参数。
在进行路由匹配的时候，要求URL解析出来的分段数必须和path的分段数一致，否则将匹配不到。比如，URL http://localhost/component-a/1/segment/angular 可以匹配例子中的path，并且路由参数id的值为"1"，name的值为"angular"。URL http://localhost/component-a/1 或者http://localhost/component-a/1/segment/angular/2 都匹配不到该路由。
@RouteConfig([
  { path: '/component-a/:id/segment/:name' }
])

Param_route_path
_parsePathString
将url根据／划分成段（每段可以有以下四种类型），并按如下顺序进行匹配
DynamicPathSegment， StarPathSegment， ContinuationPathSegment，StaticPathSegment


为了简化起见，下面的例子只设置了一个路由参数。同样，直接在浏览器输入URL http://localhost/component-a/1 或者点击超链接，都可以在页面上把ComponentA显示出来。
app.component.ts
@RouteConfig([
  {
    path: '/component-a/:id',
    name: 'Component-A',
    component: ComponentA
  }
])
@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <nav>
      <a [routerLink]="['Component-A', {id:1}]">Component A</a>
    </nav>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
需要注意的是，对于带参数的路由，routerLink指令必须提供相应的参数值。如果将例子做如下改动，由于routerLink指令无法提供值给参数id，会导致Angular2抛出异常EXCEPTION: Route generator for 'id' was not included in parameters passed。
<a [routerLink]="['Component-A']">Component A</a>
<a [routerLink]="['Component-A', {name:1}]">Component A</a>


获取路由参数
在每次URL发生改变的时候，Angular2都会为新的URL生成一个RouteParams的实例，用于存储路由参数（即便新URL没有参数）。通过把这个实例注入到新URL相应的Component之中，便可以获取路由参数。
下面的例子获取了路由参数id，并将其输出于Component上。
a.component.ts
import { Component } from 'angular2/core';
import { RouteParams } from 'angular2/router';

@Component({
  template: `
    <div>Component A</div>
    <div>id: {{id}}</div>
  `
})
export class ComponentA {
  constructor(routeParams:RouteParams) {
    this.id = routeParams.get("id");
  }
}


子路由
到目前为止，所举的例子都是围绕如何通过路由来控制一个Component是否显示。在第二章组件章节介绍过，一个Component可以嵌套任意多个子Component。相应的，Angular2提供了子路由的机制，可以通过路由来控制子Component是否显示。

下面对主页面的路由定义稍作修改：
app.component.ts
@RouteConfig([
  {
    path: '/component-a/...',
    name: 'Component-A',
    component: ComponentA
  }
])
@Component({
  selector: 'my-app',
  template: `
    <h1>Master Page</h1>
    <router-outlet></router-outlet>
  `,
  directives: [ROUTER_DIRECTIVES]
})
class AppComponent { }
在路由定义中，如果path的最后一个分段为"…"，那么该路由则被称为非终结路由(non-terminal route)。一个非终结路由本身不能匹配任何URL，就好比面相对象编程中，一个抽象类不能够被实例化一样。所以如果运行上面的例子，在浏览器上输入http://localhost:3000/component-a/，ComponentA不会被显示出来。
要显示ComponentA，需要给其子Component定义路由，并将此子路由与非终结路由拼接起来，构造出一个完整的可用于匹配的URL。下面的例子给子Component各定义了一个路由，于是使用URL http://localhost:3000/component-a/component-child-1 和 http://localhost:3000/component-a/component-child-2 便可将父Component及其相应的子Component显示出来。就好比一个抽象类被非抽象子类继承，在实例化子类的时候，抽象类的内容也会连带生成。
a.component.ts
import { Component } from 'angular2/core';
import { RouteConfig, RouterOutlet } from 'angular2/router';

import { ComponentChild1 } from './child1.component';
import { ComponentChild2 } from './child2.component';

@RouteConfig([
  {
    path: '/component-child-1',
    name: 'Component-Child-1',
    component: ComponentChild1,
    useAsDefault: true
  },
  {
    path: '/component-child-2',
    name: 'Component-Child-2',
    component: ComponentChild2
  }
])
@Component({
  template: `
    <div>Component A</div>
    <router-outlet></router-outlet>
  `,
  directives: [RouterOutlet]
})
export class ComponentA {}
child1.component.ts
import { Component } from 'angular2/core';

@Component({
  template: `<div>Component Child 1</div>`
})
export class ComponentChild1 {}
child2.component.ts
import { Component } from 'angular2/core';

@Component({
  template: `<div>Component Child 2</div>`
})
export class ComponentChild2 {}




